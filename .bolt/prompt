# Email Wizard - Technical Knowledge Base

**Version:** 2.0  
**Last Updated:** November 2025  
**Purpose:** Complete technical reference for Bolt.new

---

## Table of Contents
1. [Complete Database Schema](#complete-database-schema)
2. [API Endpoints Reference](#api-endpoints-reference)
3. [SendGrid Integration](#sendgrid-integration)
4. [Stripe Integration](#stripe-integration)
5. [BullMQ Queues](#bullmq-queues)
6. [Authentication Flow](#authentication-flow)
7. [Plan Features Matrix](#plan-features-matrix)
8. [Code Snippets Library](#code-snippets-library)

---

## Complete Database Schema

### Core Tables

```sql
-- ============================================================================
-- ORGANIZATIONS (Multi-tenant accounts)
-- ============================================================================
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    plan VARCHAR(50) DEFAULT 'free' CHECK (plan IN ('free', 'pro', 'pro_plus')),
    stripe_customer_id VARCHAR(100) UNIQUE,
    stripe_subscription_id VARCHAR(100) UNIQUE,
    monthly_email_limit INTEGER DEFAULT 1000,
    emails_sent_this_month INTEGER DEFAULT 0,
    billing_cycle_start DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_orgs_plan ON organizations(plan);
CREATE INDEX idx_orgs_stripe_customer ON organizations(stripe_customer_id);

-- ============================================================================
-- USERS (Authentication)
-- ============================================================================
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    email_verified BOOLEAN DEFAULT FALSE,
    verification_token VARCHAR(255),
    totp_secret VARCHAR(100), -- For 2FA
    backup_codes TEXT[], -- Recovery codes
    last_login_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);

-- ============================================================================
-- ORGANIZATION MEMBERSHIP (Team access)
-- ============================================================================
CREATE TABLE organization_users (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) DEFAULT 'owner' CHECK (role IN ('owner', 'admin', 'editor', 'viewer')),
    invited_by UUID REFERENCES users(id),
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY(organization_id, user_id)
);

CREATE INDEX idx_org_users_user ON organization_users(user_id);

-- ============================================================================
-- CONTACTS (Email recipients)
-- ============================================================================
CREATE TABLE contacts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    phone VARCHAR(50),
    country VARCHAR(100),
    industry VARCHAR(100),
    company VARCHAR(255),
    custom_fields JSONB DEFAULT '{}',
    subscribed BOOLEAN DEFAULT TRUE,
    engagement_score INTEGER DEFAULT 0, -- 0-100
    last_engaged_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(organization_id, email)
);

CREATE INDEX idx_contacts_org_email ON contacts(organization_id, email);
CREATE INDEX idx_contacts_subscribed ON contacts(organization_id, subscribed);
CREATE INDEX idx_contacts_engagement ON contacts(organization_id, engagement_score);
CREATE INDEX idx_contacts_custom_fields ON contacts USING GIN (custom_fields);

-- ============================================================================
-- CONTACT LISTS
-- ============================================================================
CREATE TABLE contact_lists (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    contact_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_lists_org ON contact_lists(organization_id);

-- ============================================================================
-- CONTACT LIST MEMBERSHIP
-- ============================================================================
CREATE TABLE contact_list_members (
    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    list_id UUID NOT NULL REFERENCES contact_lists(id) ON DELETE CASCADE,
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    source VARCHAR(50), -- import, form, api, automation
    PRIMARY KEY(contact_id, list_id)
);

CREATE INDEX idx_list_members_list ON contact_list_members(list_id);

-- ============================================================================
-- TAGS (Flexible categorization)
-- ============================================================================
CREATE TABLE tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    color VARCHAR(7), -- Hex color
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(organization_id, name)
);

CREATE TABLE contact_tags (
    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
    tagged_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY(contact_id, tag_id)
);

CREATE INDEX idx_contact_tags_tag ON contact_tags(tag_id);

-- ============================================================================
-- SEGMENTS (Dynamic groups based on rules)
-- ============================================================================
CREATE TABLE segments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    conditions JSONB NOT NULL, -- Segment rules
    last_calculated_at TIMESTAMP WITH TIME ZONE,
    contact_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_segments_org ON segments(organization_id);

-- ============================================================================
-- TEMPLATES
-- ============================================================================
CREATE TABLE templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    template_type VARCHAR(50) DEFAULT 'custom' CHECK (template_type IN ('custom', 'preset', 'locked')),
    category VARCHAR(100), -- newsletter, promotional, transactional
    subject_line VARCHAR(255),
    preview_text VARCHAR(150),
    html_content TEXT NOT NULL,
    design_json JSONB, -- Visual editor state
    is_locked BOOLEAN DEFAULT FALSE, -- Locked templates can't be edited
    supports_merge BOOLEAN DEFAULT TRUE, -- Personalization support
    thumbnail_url VARCHAR(500),
    created_by UUID REFERENCES users(id),
    is_public BOOLEAN DEFAULT FALSE, -- Platform-wide template
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_templates_org ON templates(organization_id);
CREATE INDEX idx_templates_type ON templates(template_type);
CREATE INDEX idx_templates_public ON templates(is_public) WHERE is_public = true;

-- ============================================================================
-- CAMPAIGNS
-- ============================================================================
CREATE TABLE campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    campaign_type VARCHAR(50) DEFAULT 'regular' CHECK (campaign_type IN ('regular', 'ab_test', 'automation')),
    status VARCHAR(50) DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'sending', 'sent', 'paused', 'failed')),
    template_id UUID REFERENCES templates(id),
    subject_line VARCHAR(255) NOT NULL,
    preview_text VARCHAR(150),
    from_name VARCHAR(100) NOT NULL,
    from_email VARCHAR(255) NOT NULL,
    reply_to VARCHAR(255),
    html_content TEXT NOT NULL,
    send_to_type VARCHAR(50) CHECK (send_to_type IN ('list', 'segment', 'tag', 'all')),
    send_to_ids UUID[], -- Array of list/segment/tag IDs
    scheduled_at TIMESTAMP WITH TIME ZONE,
    sent_at TIMESTAMP WITH TIME ZONE,
    
    -- Stats
    recipient_count INTEGER DEFAULT 0,
    delivered_count INTEGER DEFAULT 0,
    opened_count INTEGER DEFAULT 0,
    unique_opened_count INTEGER DEFAULT 0,
    clicked_count INTEGER DEFAULT 0,
    unique_clicked_count INTEGER DEFAULT 0,
    bounced_count INTEGER DEFAULT 0,
    unsubscribed_count INTEGER DEFAULT 0,
    complained_count INTEGER DEFAULT 0,
    
    -- SendGrid integration
    sendgrid_batch_id VARCHAR(100),
    
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_campaigns_org ON campaigns(organization_id);
CREATE INDEX idx_campaigns_status ON campaigns(organization_id, status);
CREATE INDEX idx_campaigns_scheduled ON campaigns(scheduled_at) WHERE status = 'scheduled';
CREATE INDEX idx_campaigns_sent ON campaigns(sent_at) WHERE status = 'sent';

-- ============================================================================
-- A/B TEST VARIANTS
-- ============================================================================
CREATE TABLE campaign_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
    variant_name VARCHAR(50) NOT NULL, -- A, B, C
    subject_line VARCHAR(255),
    html_content TEXT,
    recipient_percentage INTEGER, -- 25, 50, 25
    recipient_count INTEGER DEFAULT 0,
    delivered_count INTEGER DEFAULT 0,
    opened_count INTEGER DEFAULT 0,
    clicked_count INTEGER DEFAULT 0,
    is_winner BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_variants_campaign ON campaign_variants(campaign_id);

-- ============================================================================
-- EMAIL EVENTS (From SendGrid webhooks)
-- ============================================================================
CREATE TABLE email_events (
    id BIGSERIAL PRIMARY KEY,
    campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
    contact_id UUID REFERENCES contacts(id) ON DELETE CASCADE,
    event_type VARCHAR(50) NOT NULL CHECK (event_type IN (
        'queued', 'processed', 'delivered', 'opened', 'clicked',
        'bounced', 'deferred', 'dropped', 'spam', 'unsubscribe'
    )),
    email VARCHAR(255) NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    user_agent TEXT,
    ip_address VARCHAR(45),
    url VARCHAR(1000), -- For click events
    bounce_reason TEXT, -- For bounce events
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_events_campaign ON email_events(campaign_id, event_type);
CREATE INDEX idx_events_contact ON email_events(contact_id, event_type);
CREATE INDEX idx_events_timestamp ON email_events(timestamp DESC);
CREATE INDEX idx_events_type ON email_events(event_type);

-- Partition by month for performance
CREATE TABLE email_events_y2025m01 PARTITION OF email_events
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- ============================================================================
-- LINK CLICKS (Detailed tracking)
-- ============================================================================
CREATE TABLE link_clicks (
    id BIGSERIAL PRIMARY KEY,
    campaign_id UUID NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    url VARCHAR(500) NOT NULL,
    clicked_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_clicks_campaign ON link_clicks(campaign_id);
CREATE INDEX idx_clicks_contact ON link_clicks(contact_id);

-- ============================================================================
-- ANALYTICS (Daily aggregates for performance)
-- ============================================================================
CREATE TABLE analytics_daily (
    id BIGSERIAL PRIMARY KEY,
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
    metric_date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    emails_complained INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    open_rate DECIMAL(5,2), -- Percentage
    click_rate DECIMAL(5,2),
    bounce_rate DECIMAL(5,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(organization_id, campaign_id, metric_date)
);

CREATE INDEX idx_analytics_org_date ON analytics_daily(organization_id, metric_date);
CREATE INDEX idx_analytics_campaign ON analytics_daily(campaign_id, metric_date);

-- ============================================================================
-- CUSTOM SENDING DOMAINS
-- ============================================================================
CREATE TABLE sending_domains (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    domain VARCHAR(255) NOT NULL,
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'verifying', 'verified', 'failed')),
    verification_method VARCHAR(50) DEFAULT 'dns',
    dns_records JSONB, -- SPF, DKIM, DMARC records
    sendgrid_domain_id VARCHAR(100),
    verified_at TIMESTAMP WITH TIME ZONE,
    last_check_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    is_default BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(organization_id, domain)
);

CREATE INDEX idx_domains_org ON sending_domains(organization_id);
CREATE INDEX idx_domains_status ON sending_domains(status);

-- ============================================================================
-- SUPPRESSIONS (Unsubscribes, bounces, complaints)
-- ============================================================================
CREATE TABLE suppressions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    suppression_type VARCHAR(50) NOT NULL CHECK (suppression_type IN (
        'unsubscribe', 'bounce', 'spam_complaint', 'manual'
    )),
    reason TEXT,
    campaign_id UUID REFERENCES campaigns(id),
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(organization_id, email, suppression_type)
);

CREATE INDEX idx_suppressions_org_email ON suppressions(organization_id, email);
CREATE INDEX idx_suppressions_type ON suppressions(suppression_type);

-- ============================================================================
-- AUTOMATION WORKFLOWS (PRO PLUS ONLY)
-- ============================================================================
CREATE TABLE automation_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    trigger_type VARCHAR(50) NOT NULL CHECK (trigger_type IN (
        'list_subscribe', 'tag_added', 'date_based', 'custom_event', 'form_submit'
    )),
    trigger_config JSONB NOT NULL, -- Trigger-specific settings
    workflow_steps JSONB NOT NULL, -- Array of steps
    is_active BOOLEAN DEFAULT FALSE,
    last_triggered_at TIMESTAMP WITH TIME ZONE,
    total_executions INTEGER DEFAULT 0,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_workflows_org ON automation_workflows(organization_id);
CREATE INDEX idx_workflows_active ON automation_workflows(is_active) WHERE is_active = true;

-- ============================================================================
-- AUTOMATION EXECUTIONS (Track each automation run)
-- ============================================================================
CREATE TABLE automation_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES automation_workflows(id) ON DELETE CASCADE,
    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    status VARCHAR(50) DEFAULT 'running' CHECK (status IN ('running', 'completed', 'failed', 'paused')),
    current_step INTEGER DEFAULT 0,
    started_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT
);

CREATE INDEX idx_executions_workflow ON automation_executions(workflow_id, status);
CREATE INDEX idx_executions_contact ON automation_executions(contact_id);

-- ============================================================================
-- ADMIN TABLES
-- ============================================================================

-- Admin users (separate from customer users)
CREATE TABLE admin_users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    admin_role VARCHAR(50) NOT NULL CHECK (admin_role IN (
        'super_admin', 'support_admin', 'finance_admin', 'readonly_admin'
    )),
    totp_secret VARCHAR(100), -- 2FA required for admins
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Admin activity log
CREATE TABLE admin_activity_log (
    id BIGSERIAL PRIMARY KEY,
    admin_id UUID NOT NULL REFERENCES admin_users(id),
    action_type VARCHAR(100) NOT NULL,
    resource_type VARCHAR(100), -- user, campaign, organization
    resource_id UUID,
    details JSONB,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_admin_log_admin ON admin_activity_log(admin_id, created_at);
CREATE INDEX idx_admin_log_resource ON admin_activity_log(resource_type, resource_id);

-- Platform metrics (for admin dashboard)
CREATE TABLE platform_metrics_daily (
    id BIGSERIAL PRIMARY KEY,
    metric_date DATE NOT NULL UNIQUE,
    total_organizations INTEGER DEFAULT 0,
    new_organizations INTEGER DEFAULT 0,
    active_organizations INTEGER DEFAULT 0, -- Sent email in last 30 days
    free_plan_count INTEGER DEFAULT 0,
    pro_plan_count INTEGER DEFAULT 0,
    pro_plus_plan_count INTEGER DEFAULT 0,
    total_emails_sent BIGINT DEFAULT 0,
    total_revenue DECIMAL(10,2) DEFAULT 0,
    mrr DECIMAL(10,2) DEFAULT 0, -- Monthly Recurring Revenue
    avg_emails_per_org INTEGER DEFAULT 0,
    platform_bounce_rate DECIMAL(5,2),
    platform_complaint_rate DECIMAL(5,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_platform_metrics_date ON platform_metrics_daily(metric_date DESC);

-- Abuse reports
CREATE TABLE abuse_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID REFERENCES organizations(id) ON DELETE SET NULL,
    campaign_id UUID REFERENCES campaigns(id) ON DELETE SET NULL,
    reporter_email VARCHAR(255),
    abuse_type VARCHAR(50) CHECK (abuse_type IN ('spam', 'phishing', 'harassment', 'other')),
    description TEXT,
    status VARCHAR(50) DEFAULT 'open' CHECK (status IN ('open', 'investigating', 'resolved', 'dismissed')),
    assigned_to UUID REFERENCES admin_users(id),
    resolved_at TIMESTAMP WITH TIME ZONE,
    resolution_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_abuse_reports_status ON abuse_reports(status);
CREATE INDEX idx_abuse_reports_org ON abuse_reports(organization_id);
```

---

## API Endpoints Reference

### Authentication Endpoints

#### POST /api/auth/register
**Request:**
```json
{
  "email": "user@example.com",
  "password": "SecurePassword123!",
  "firstName": "John",
  "lastName": "Doe",
  "organizationName": "Acme Corp"
}
```

**Response:**
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIs...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIs...",
  "user": {
    "id": "uuid",
    "email": "user@example.com",
    "organizationId": "uuid",
    "role": "owner",
    "plan": "free"
  }
}
```

#### POST /api/auth/login
**Request:**
```json
{
  "email": "user@example.com",
  "password": "SecurePassword123!"
}
```

**Response:** Same as register

#### POST /api/auth/refresh
**Request:**
```json
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIs..."
}
```

**Response:**
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIs..."
}
```

---

### Campaign Endpoints

#### GET /api/campaigns
**Headers:** `Authorization: Bearer {token}`

**Response:**
```json
{
  "campaigns": [
    {
      "id": "uuid",
      "name": "Summer Newsletter",
      "status": "sent",
      "subjectLine": "Our Summer Sale is Here!",
      "recipientCount": 1500,
      "deliveredCount": 1485,
      "openedCount": 445,
      "clickedCount": 89,
      "openRate": 30.0,
      "clickRate": 6.0,
      "sentAt": "2025-06-15T10:00:00Z",
      "createdAt": "2025-06-10T14:30:00Z"
    }
  ],
  "total": 15,
  "page": 1,
  "pageSize": 20
}
```

#### POST /api/campaigns
**Headers:** `Authorization: Bearer {token}`

**Request:**
```json
{
  "name": "Welcome Series - Email 1",
  "subjectLine": "Welcome to Email Wizard!",
  "fromName": "Email Wizard Team",
  "fromEmail": "hello@emailwizard.com",
  "templateId": "uuid",
  "htmlContent": "<html>...</html>",
  "sendToType": "list",
  "sendToIds": ["list-uuid-1", "list-uuid-2"]
}
```

**Response:**
```json
{
  "id": "uuid",
  "name": "Welcome Series - Email 1",
  "status": "draft",
  "createdAt": "2025-11-16T10:00:00Z"
}
```

#### POST /api/campaigns/:id/send
**Headers:** `Authorization: Bearer {token}`

**Request:**
```json
{
  "scheduledAt": "2025-11-20T14:00:00Z" // Optional, immediate if omitted
}
```

**Response:**
```json
{
  "success": true,
  "campaignId": "uuid",
  "recipientCount": 1500,
  "status": "queued",
  "estimatedCompletionTime": "2025-11-20T14:05:00Z"
}
```

#### GET /api/campaigns/:id/analytics
**Headers:** `Authorization: Bearer {token}`

**Response:**
```json
{
  "campaignId": "uuid",
  "stats": {
    "sent": 1500,
    "delivered": 1485,
    "opened": 445,
    "clicked": 89,
    "bounced": 15,
    "unsubscribed": 3,
    "complained": 1,
    "openRate": 30.0,
    "clickRate": 6.0,
    "bounceRate": 1.0
  },
  "topLinks": [
    { "url": "https://example.com/product", "clicks": 45 },
    { "url": "https://example.com/signup", "clicks": 32 }
  ],
  "timeline": [
    { "date": "2025-11-16", "delivered": 500, "opened": 150, "clicked": 30 },
    { "date": "2025-11-17", "delivered": 985, "opened": 295, "clicked": 59 }
  ]
}
```

---

### Contact Endpoints

#### GET /api/contacts
**Headers:** `Authorization: Bearer {token}`

**Query Params:**
- `page` (default: 1)
- `pageSize` (default: 50)
- `search` (filter by email, name)
- `listId` (filter by list)
- `tagId` (filter by tag)
- `subscribed` (true/false)

**Response:**
```json
{
  "contacts": [
    {
      "id": "uuid",
      "email": "contact@example.com",
      "firstName": "Jane",
      "lastName": "Smith",
      "subscribed": true,
      "engagementScore": 75,
      "tags": ["vip", "newsletter"],
      "lists": ["General Newsletter", "Product Updates"],
      "createdAt": "2025-01-15T10:00:00Z"
    }
  ],
  "total": 5420,
  "page": 1,
  "pageSize": 50
}
```

#### POST /api/contacts
**Headers:** `Authorization: Bearer {token}`

**Request:**
```json
{
  "email": "newcontact@example.com",
  "firstName": "John",
  "lastName": "Doe",
  "customFields": {
    "company": "Acme Corp",
    "industry": "Technology"
  },
  "listIds": ["uuid1", "uuid2"],
  "tagIds": ["uuid3"]
}
```

**Response:**
```json
{
  "id": "uuid",
  "email": "newcontact@example.com",
  "createdAt": "2025-11-16T10:00:00Z"
}
```

#### POST /api/contacts/import
**Headers:** `Authorization: Bearer {token}`, `Content-Type: multipart/form-data`

**Request:** CSV file upload

**Response:**
```json
{
  "jobId": "uuid",
  "status": "processing",
  "totalRows": 5000,
  "message": "Import started. You'll receive an email when complete."
}
```

---

### Billing Endpoints

#### POST /api/billing/create-checkout
**Headers:** `Authorization: Bearer {token}`

**Request:**
```json
{
  "plan": "pro" // or "pro_plus"
}
```

**Response:**
```json
{
  "url": "https://checkout.stripe.com/pay/cs_test_..."
}
```

#### GET /api/billing/subscription
**Headers:** `Authorization: Bearer {token}`

**Response:**
```json
{
  "plan": "pro",
  "status": "active",
  "currentPeriodEnd": "2025-12-16T00:00:00Z",
  "cancelAtPeriodEnd": false,
  "monthlyEmailLimit": 10000,
  "emailsSentThisMonth": 3450,
  "billingCycleStart": "2025-11-16"
}
```

#### POST /api/billing/cancel
**Headers:** `Authorization: Bearer {token}`

**Response:**
```json
{
  "success": true,
  "message": "Subscription will cancel at end of billing period",
  "cancelAt": "2025-12-16T00:00:00Z"
}
```

---

### Domain Endpoints

#### POST /api/domains
**Headers:** `Authorization: Bearer {token}`

**Request:**
```json
{
  "domain": "mail.example.com"
}
```

**Response:**
```json
{
  "id": "uuid",
  "domain": "mail.example.com",
  "status": "pending",
  "dnsRecords": {
    "dkim": {
      "type": "CNAME",
      "host": "s1._domainkey.mail.example.com",
      "value": "s1.domainkey.u12345.wl.sendgrid.net"
    },
    "spf": {
      "type": "TXT",
      "host": "mail.example.com",
      "value": "v=spf1 include:sendgrid.net ~all"
    },
    "dmarc": {
      "type": "TXT",
      "host": "_dmarc.mail.example.com",
      "value": "v=DMARC1; p=none; rua=mailto:dmarc@example.com"
    }
  }
}
```

#### POST /api/domains/:id/verify
**Headers:** `Authorization: Bearer {token}`

**Response:**
```json
{
  "id": "uuid",
  "domain": "mail.example.com",
  "status": "verified",
  "verifiedAt": "2025-11-16T10:30:00Z"
}
```

---

### Admin Endpoints

#### GET /api/admin/dashboard/metrics
**Headers:** `Authorization: Bearer {adminToken}`

**Response:**
```json
{
  "organizations": {
    "total": 1523,
    "new_today": 12,
    "active_30d": 890,
    "by_plan": {
      "free": 1200,
      "pro": 250,
      "pro_plus": 73
    }
  },
  "revenue": {
    "mrr": 29450.00,
    "total_today": 1250.00,
    "growth_30d": 12.5
  },
  "emails": {
    "sent_today": 125000,
    "sent_30d": 3500000,
    "avg_per_org": 2300
  },
  "deliverability": {
    "bounce_rate": 0.45,
    "complaint_rate": 0.02,
    "avg_open_rate": 22.5
  }
}
```

#### GET /api/admin/users/:orgId
**Headers:** `Authorization: Bearer {adminToken}`

**Response:**
```json
{
  "id": "uuid",
  "name": "Acme Corp",
  "plan": "pro",
  "status": "active",
  "emailsSentThisMonth": 5420,
  "monthlyLimit": 10000,
  "users": [
    {
      "email": "admin@acme.com",
      "role": "owner",
      "lastLogin": "2025-11-16T08:30:00Z"
    }
  ],
  "recentCampaigns": [...],
  "billingInfo": {
    "stripeCustomerId": "cus_xxx",
    "currentPeriodEnd": "2025-12-16T00:00:00Z"
  },
  "createdAt": "2025-01-10T00:00:00Z"
}
```

---

## SendGrid Integration

### Configuration

```typescript
// config/sendgrid.ts
import sgMail from '@sendgrid/mail';

sgMail.setApiKey(process.env.SENDGRID_API_KEY!);

export { sgMail };
```

### Sending Email

```typescript
// services/emailService.ts
import { sgMail } from '../config/sendgrid';

export async function sendEmail(params: {
  to: string;
  subject: string;
  html: string;
  fromName: string;
  fromEmail: string;
  campaignId: string;
  contactId: string;
}) {
  const msg = {
    to: params.to,
    from: {
      email: params.fromEmail,
      name: params.fromName
    },
    subject: params.subject,
    html: params.html,
    customArgs: {
      campaign_id: params.campaignId,
      contact_id: params.contactId
    },
    trackingSettings: {
      clickTracking: {
        enable: true,
        enableText: false
      },
      openTracking: {
        enable: true,
        substitutionTag: '%open-track%'
      },
      subscriptionTracking: {
        enable: false // We handle unsubscribe ourselves
      }
    },
    mailSettings: {
      footer: {
        enable: false
      }
    }
  };

  try {
    const response = await sgMail.send(msg);
    console.log('Email sent:', response[0].statusCode);
    return { success: true, messageId: response[0].headers['x-message-id'] };
  } catch (error: any) {
    console.error('SendGrid error:', error.response?.body || error);
    throw new Error(`Failed to send email: ${error.message}`);
  }
}
```

### Webhook Handler

```typescript
// routes/webhooks.ts
import express from 'express';
import crypto from 'crypto';
import { pool } from '../config/database';

const router = express.Router();

// Verify SendGrid webhook signature
function verifySignature(req: express.Request): boolean {
  const signature = req.headers['x-twilio-email-event-webhook-signature'] as string;
  const timestamp = req.headers['x-twilio-email-event-webhook-timestamp'] as string;
  
  const payload = timestamp + JSON.stringify(req.body);
  const expectedSignature = crypto
    .createHmac('sha256', process.env.SENDGRID_WEBHOOK_SECRET!)
    .update(payload)
    .digest('base64');

  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

router.post('/sendgrid', async (req, res) => {
  // Always respond quickly
  res.status(200).json({ received: true });

  // Verify signature
  if (!verifySignature(req)) {
    console.error('Invalid SendGrid webhook signature');
    return;
  }

  const events = req.body;

  // Process events asynchronously
  for (const event of events) {
    try {
      await processEvent(event);
    } catch (error) {
      console.error('Error processing event:', error);
    }
  }
});

async function processEvent(event: any) {
  const { 
    event: eventType, 
    email, 
    timestamp, 
    campaign_id, 
    contact_id,
    url,
    reason
  } = event;

  // Insert event record
  await pool.query(`
    INSERT INTO email_events (
      campaign_id, contact_id, event_type, email, 
      timestamp, url, bounce_reason, metadata
    ) VALUES ($1, $2, $3, $4, to_timestamp($5), $6, $7, $8)
  `, [
    campaign_id,
    contact_id,
    eventType,
    email,
    timestamp,
    url || null,
    reason || null,
    JSON.stringify(event)
  ]);

  // Update campaign stats
  const statColumn = `${eventType}_count`;
  await pool.query(`
    UPDATE campaigns
    SET ${statColumn} = ${statColumn} + 1
    WHERE id = $1
  `, [campaign_id]);

  // Handle specific events
  switch (eventType) {
    case 'unsubscribe':
      await pool.query(`
        UPDATE contacts SET subscribed = false WHERE id = $1
      `, [contact_id]);
      
      await pool.query(`
        INSERT INTO suppressions (organization_id, email, suppression_type, campaign_id)
        SELECT organization_id, $1, 'unsubscribe', $2
        FROM contacts WHERE id = $3
        ON CONFLICT DO NOTHING
      `, [email, campaign_id, contact_id]);
      break;

    case 'spam':
      await pool.query(`
        INSERT INTO suppressions (organization_id, email, suppression_type, campaign_id)
        SELECT organization_id, $1, 'spam_complaint', $2
        FROM contacts WHERE id = $3
        ON CONFLICT DO NOTHING
      `, [email, campaign_id, contact_id]);
      break;

    case 'bounced':
      await pool.query(`
        INSERT INTO suppressions (organization_id, email, suppression_type, reason, campaign_id)
        SELECT organization_id, $1, 'bounce', $2, $3
        FROM contacts WHERE id = $4
        ON CONFLICT DO NOTHING
      `, [email, reason, campaign_id, contact_id]);
      break;

    case 'opened':
      // Update engagement score
      await pool.query(`
        UPDATE contacts
        SET 
          engagement_score = LEAST(engagement_score + 2, 100),
          last_engaged_at = NOW()
        WHERE id = $1
      `, [contact_id]);
      break;

    case 'clicked':
      // Track link click
      await pool.query(`
        INSERT INTO link_clicks (campaign_id, contact_id, url)
        VALUES ($1, $2, $3)
      `, [campaign_id, contact_id, url]);

      // Update engagement score
      await pool.query(`
        UPDATE contacts
        SET 
          engagement_score = LEAST(engagement_score + 5, 100),
          last_engaged_at = NOW()
        WHERE id = $1
      `, [contact_id]);
      break;
  }
}

export default router;
```

---

## Stripe Integration

### Configuration

```typescript
// config/stripe.ts
import Stripe from 'stripe';

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
  typescript: true
});
```

### Checkout Session Creation

```typescript
// routes/billing.ts
import express from 'express';
import { stripe } from '../config/stripe';
import { authenticate } from '../middleware/auth';

const router = express.Router();

router.post('/create-checkout', authenticate, async (req, res) => {
  try {
    const { plan } = req.body;
    const { organizationId, email } = req.user;

    // Validate plan
    if (!['pro', 'pro_plus'].includes(plan)) {
      return res.status(400).json({ error: 'Invalid plan' });
    }

    const priceId = plan === 'pro'
      ? process.env.STRIPE_PRICE_ID_PRO
      : process.env.STRIPE_PRICE_ID_PRO_PLUS;

    const session = await stripe.checkout.sessions.create({
      customer_email: email,
      mode: 'subscription',
      payment_method_types: ['card'],
      line_items: [{
        price: priceId,
        quantity: 1
      }],
      success_url: `${process.env.APP_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.APP_URL}/billing`,
      metadata: {
        organizationId,
        plan
      },
      subscription_data: {
        metadata: {
          organizationId,
          plan
        }
      }
    });

    res.json({ url: session.url });
  } catch (error: any) {
    console.error('Stripe checkout error:', error);
    res.status(500).json({ error: 'Failed to create checkout session' });
  }
});

export default router;
```

### Webhook Handler

```typescript
// routes/webhooks.ts (add to existing file)
router.post('/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'] as string;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err: any) {
    console.error('Webhook signature verification failed:', err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // Handle the event
  try {
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as Stripe.Checkout.Session;
        const { organizationId, plan } = session.metadata!;

        // Update organization
        await pool.query(`
          UPDATE organizations
          SET 
            plan = $1,
            stripe_customer_id = $2,
            stripe_subscription_id = $3,
            monthly_email_limit = $4,
            billing_cycle_start = CURRENT_DATE,
            updated_at = NOW()
          WHERE id = $5
        `, [
          plan,
          session.customer,
          session.subscription,
          plan === 'pro' ? 10000 : 50000,
          organizationId
        ]);

        console.log(`Subscription activated for org ${organizationId}`);
        break;
      }

      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription;
        
        // Check if subscription was canceled
        if (subscription.cancel_at_period_end) {
          console.log(`Subscription will cancel at ${subscription.current_period_end}`);
        }
        break;
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription;
        
        // Downgrade to free plan
        await pool.query(`
          UPDATE organizations
          SET 
            plan = 'free',
            monthly_email_limit = 1000,
            stripe_subscription_id = NULL,
            updated_at = NOW()
          WHERE stripe_subscription_id = $1
        `, [subscription.id]);

        console.log(`Subscription canceled: ${subscription.id}`);
        break;
      }

      case 'invoice.payment_failed': {
        const invoice = event.data.object as Stripe.Invoice;
        
        // Notify user of payment failure
        console.error(`Payment failed for customer ${invoice.customer}`);
        // TODO: Send notification email
        break;
      }

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    res.json({ received: true });
  } catch (error) {
    console.error('Error processing Stripe webhook:', error);
    res.status(500).json({ error: 'Webhook processing failed' });
  }
});
```

---

## BullMQ Queues

### Queue Configuration

```typescript
// services/queueService.ts
import { Queue, Worker, QueueEvents } from 'bullmq';

const connection = {
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379')
};

// Campaign send queue
export const campaignQueue = new Queue('campaign-send', {
  connection,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    },
    removeOnComplete: 100, // Keep last 100 completed jobs
    removeOnFail: 1000 // Keep last 1000 failed jobs
  }
});

// SendGrid event processing queue
export const eventQueue = new Queue('sendgrid-events', {
  connection,
  defaultJobOptions: {
    attempts: 5,
    backoff: {
      type: 'exponential',
      delay: 1000
    }
  }
});

// Analytics aggregation queue
export const analyticsQueue = new Queue('analytics', {
  connection,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 5000
    }
  }
});

// Contact import queue
export const importQueue = new Queue('contact-import', {
  connection,
  defaultJobOptions: {
    attempts: 2
  }
});
```

### Email Worker

```typescript
// workers/emailWorker.ts
import { Worker } from 'bullmq';
import { sendEmail } from '../services/emailService';
import { pool } from '../config/database';

const connection = {
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379')
};

const worker = new Worker('campaign-send', async (job) => {
  const { 
    campaignId, 
    contactId, 
    email, 
    subject, 
    html, 
    fromName, 
    fromEmail 
  } = job.data;

  try {
    // Check suppression list before sending
    const suppressed = await pool.query(`
      SELECT 1 FROM suppressions
      WHERE organization_id = (
        SELECT organization_id FROM campaigns WHERE id = $1
      ) AND email = $2
    `, [campaignId, email]);

    if (suppressed.rows.length > 0) {
      console.log(`Email ${email} is suppressed, skipping`);
      return { success: false, reason: 'suppressed' };
    }

    // Send email
    const result = await sendEmail({
      to: email,
      subject,
      html,
      fromName,
      fromEmail,
      campaignId,
      contactId
    });

    // Log success
    await pool.query(`
      INSERT INTO email_events (campaign_id, contact_id, email, event_type, timestamp)
      VALUES ($1, $2, $3, 'queued', NOW())
    `, [campaignId, contactId, email]);

    // Update progress
    await job.updateProgress(100);

    return { success: true, messageId: result.messageId };
  } catch (error: any) {
    console.error('Send error:', error);
    
    // Log failure
    await pool.query(`
      INSERT INTO email_events (campaign_id, contact_id, email, event_type, timestamp, metadata)
      VALUES ($1, $2, $3, 'failed', NOW(), $4)
    `, [campaignId, contactId, email, JSON.stringify({ error: error.message })]);

    throw error; // Trigger retry
  }
}, {
  connection,
  concurrency: 10, // Process 10 emails concurrently
  limiter: {
    max: 100, // Max 100 jobs
    duration: 1000 // Per second (respects SendGrid rate limits)
  }
});

worker.on('completed', (job) => {
  console.log(`✅ Email sent successfully: ${job.id}`);
});

worker.on('failed', (job, err) => {
  console.error(`❌ Email send failed: ${job?.id}`, err.message);
});

worker.on('error', (err) => {
  console.error('Worker error:', err);
});
```

---

## Authentication Flow

### Registration Flow

```typescript
// routes/auth.ts
import express from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { pool } from '../config/database';
import { z } from 'zod';

const router = express.Router();

const registerSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  firstName: z.string().min(1),
  lastName: z.string().min(1),
  organizationName: z.string().min(1)
});

router.post('/register', async (req, res) => {
  try {
    // Validate input
    const data = registerSchema.parse(req.body);

    // Check if email already exists
    const existing = await pool.query(
      'SELECT id FROM users WHERE email = $1',
      [data.email]
    );

    if (existing.rows.length > 0) {
      return res.status(400).json({ error: 'Email already registered' });
    }

    // Hash password
    const passwordHash = await bcrypt.hash(data.password, 12);

    // Start transaction
    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Create organization
      const orgResult = await client.query(`
        INSERT INTO organizations (name, plan)
        VALUES ($1, 'free')
        RETURNING id
      `, [data.organizationName]);

      const organizationId = orgResult.rows[0].id;

      // Create user
      const userResult = await client.query(`
        INSERT INTO users (email, password_hash, first_name, last_name)
        VALUES ($1, $2, $3, $4)
        RETURNING id
      `, [data.email, passwordHash, data.firstName, data.lastName]);

      const userId = userResult.rows[0].id;

      // Link user to organization as owner
      await client.query(`
        INSERT INTO organization_users (organization_id, user_id, role)
        VALUES ($1, $2, 'owner')
      `, [organizationId, userId]);

      await client.query('COMMIT');

      // Generate tokens
      const accessToken = jwt.sign(
        {
          userId,
          organizationId,
          role: 'owner'
        },
        process.env.JWT_SECRET!,
        { expiresIn: '15m' }
      );

      const refreshToken = jwt.sign(
        { userId, organizationId },
        process.env.JWT_SECRET!,
        { expiresIn: '7d' }
      );

      res.status(201).json({
        accessToken,
        refreshToken,
        user: {
          id: userId,
          email: data.email,
          firstName: data.firstName,
          lastName: data.lastName,
          organizationId,
          role: 'owner',
          plan: 'free'
        }
      });
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error: any) {
    console.error('Registration error:', error);
    
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation failed', details: error.errors });
    }

    res.status(500).json({ error: 'Registration failed' });
  }
});

export default router;
```

---

## Plan Features Matrix

```typescript
// middleware/planGating.ts
export const PLAN_FEATURES = {
  free: {
    name: 'Free',
    price: 0,
    emailLimit: 1000,
    features: [
      'basic_analytics',
      'shared_sender',
      'locked_templates'
    ],
    restrictions: {
      templatesEditable: false,
      mergeTagsEnabled: false,
      automationsEnabled: false,
      apiAccessEnabled: false,
      customDomainEnabled: false,
      abTestingEnabled: false
    }
  },
  pro: {
    name: 'Pro',
    price: 29,
    emailLimit: 10000,
    features: [
      'basic_analytics',
      'advanced_analytics',
      'shared_sender',
      'custom_sender',
      'locked_templates',
      'scheduling',
      'ab_testing'
    ],
    restrictions: {
      templatesEditable: false,
      mergeTagsEnabled: false,
      automationsEnabled: false,
      apiAccessEnabled: false,
      customDomainEnabled: true,
      abTestingEnabled: true
    }
  },
  pro_plus: {
    name: 'Pro Plus',
    price: 99,
    emailLimit: 50000,
    features: [
      'basic_analytics',
      'advanced_analytics',
      'shared_sender',
      'custom_sender',
      'unlocked_templates',
      'merge_personalization',
      'scheduling',
      'ab_testing',
      'automations',
      'api_access'
    ],
    restrictions: {
      templatesEditable: true,
      mergeTagsEnabled: true,
      automationsEnabled: true,
      apiAccessEnabled: true,
      customDomainEnabled: true,
      abTestingEnabled: true
    }
  }
};

export function requireFeature(feature: string) {
  return (req: any, res: any, next: any) => {
    const userPlan = req.user.plan;
    const hasFeature = PLAN_FEATURES[userPlan]?.features.includes(feature);

    if (!hasFeature) {
      const availableIn = Object.entries(PLAN_FEATURES)
        .filter(([, config]) => config.features.includes(feature))
        .map(([plan]) => plan);

      return res.status(403).json({
        error: 'Feature not available',
        feature,
        currentPlan: userPlan,
        availableIn,
        upgradeUrl: '/billing/upgrade'
      });
    }

    next();
  };
}

export function checkEmailQuota() {
  return async (req: any, res: any, next: any) => {
    const { organizationId } = req.user;

    const result = await pool.query(`
      SELECT 
        plan,
        monthly_email_limit,
        emails_sent_this_month
      FROM organizations
      WHERE id = $1
    `, [organizationId]);

    const org = result.rows[0];
    const remaining = org.monthly_email_limit - org.emails_sent_this_month;

    if (remaining <= 0) {
      return res.status(403).json({
        error: 'Email quota exceeded',
        limit: org.monthly_email_limit,
        sent: org.emails_sent_this_month,
        upgradeUrl: '/billing/upgrade'
      });
    }

    req.emailQuota = {
      limit: org.monthly_email_limit,
      sent: org.emails_sent_this_month,
      remaining
    };

    next();
  };
}
```

---

This knowledge base provides Bolt.new with complete reference documentation for implementing Email Wizard. Every endpoint, schema, and integration pattern is documented with working code examples.